import { Dispatch, SetStateAction } from "react";
import { QueryObserverResult, UseQueryOptions } from "@tanstack/react-query";
import { BaseRecord, CreateResponse, GetOneResponse, HttpError, LiveModeProps, RedirectAction, SuccessErrorNotification, UpdateResponse, MutationMode, BaseKey, IQueryKeys, FormAction, MetaQuery } from "../../interfaces";
import { UseUpdateProps, UseUpdateReturnType } from "../data/useUpdate";
import { UseCreateProps, UseCreateReturnType } from "../data/useCreate";
export declare type ActionParams = {
    /**
     * Type of the form mode
     * @default Action that it reads from route otherwise "create" is used
     */
    action?: FormAction;
};
declare type ActionFormProps<TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError, TVariables = {}> = {
    /**
     * Resource name for API data interactions
     * @default Resource name that it reads from route
     */
    resource?: string;
    /**
     * Record id for fetching
     * @default Id that it reads from the URL
     */
    id?: BaseKey;
    /**
     * Page to redirect after a succesfull mutation
     * @type `"show" | "edit" | "list" | "create" | false`
     * @default `"list"`
     */
    redirect?: RedirectAction;
    /**
     * Metadata query for dataProvider
     */
    meta?: MetaQuery;
    /**
     * Metadata query for dataProvider
     * @deprecated `metaData` is deprecated with refine@4, refine will pass `meta` instead, however, we still support `metaData` for backward compatibility.
     */
    metaData?: MetaQuery;
    /**
     * [Determines when mutations are executed](/advanced-tutorials/mutation-mode.md)
     * @default `"pessimistic"*`
     */
    mutationMode?: MutationMode;
    /**
     * Called when a mutation is successful
     */
    onMutationSuccess?: (data: CreateResponse<TData> | UpdateResponse<TData>, variables: TVariables, context: any) => void;
    /**
     * Called when a mutation encounters an error
     */
    onMutationError?: (error: TError, variables: TVariables, context: any) => void;
    /**
     * Duration to wait before executing mutations when `mutationMode = "undoable"`
     * @default `5000*`
     */
    undoableTimeout?: number;
    /**
     * If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use.
     */
    dataProviderName?: string;
    /**
     * You can use it to manage the invalidations that will occur at the end of the mutation.
     * @type  `all`, `resourceAll`, `list`, `many`, `detail`, `false`
     * @default `["list", "many", "detail"]`
     */
    invalidates?: Array<keyof IQueryKeys>;
    /**
     * react-query's [useQuery](https://tanstack.com/query/v4/docs/reference/useQuery) options of useOne hook used while in edit mode.
     */
    queryOptions?: UseQueryOptions<GetOneResponse<TData>, HttpError>;
    /**
     * react-query's [useMutation](https://tanstack.com/query/v4/docs/reference/useMutation) options of useCreate hook used while submitting in create and clone modes.
     */
    createMutationOptions?: UseCreateProps<TData, TError, TVariables>["mutationOptions"];
    /**
     * react-query's [useMutation](https://tanstack.com/query/v4/docs/reference/useMutation) options of useUpdate hook used while submitting in edit mode.
     */
    updateMutationOptions?: UseUpdateProps<TData, TError, TVariables>["mutationOptions"];
} & SuccessErrorNotification<UpdateResponse<TData> | CreateResponse<TData>, TError, {
    id: BaseKey;
    values: TVariables;
} | TVariables> & ActionParams & LiveModeProps;
export declare type UseFormProps<TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError, TVariables = {}> = ActionFormProps<TData, TError, TVariables> & ActionParams & LiveModeProps;
export declare type UseFormReturnType<TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError, TVariables = {}> = {
    id?: BaseKey;
    setId: Dispatch<SetStateAction<BaseKey | undefined>>;
    queryResult?: QueryObserverResult<GetOneResponse<TData>>;
    mutationResult: UseUpdateReturnType<TData, TError, TVariables> | UseCreateReturnType<TData, TError, TVariables>;
    formLoading: boolean;
    onFinish: (values: TVariables) => Promise<CreateResponse<TData> | UpdateResponse<TData> | void>;
    redirect: (redirect: RedirectAction, idFromFunction?: BaseKey | undefined, routeParams?: Record<string, string | number>) => void;
};
/**
 * `useForm` is used to manage forms. It uses Ant Design {@link https://ant.design/components/form/ Form} data scope management under the hood and returns the required props for managing the form actions.
 *
 * @see {@link https://refine.dev/docs/api-references/hooks/form/useForm} for more details.
 *
 * @typeParam TData - Result data of the query extends {@link https://refine.dev/docs/api-references/interfaceReferences#baserecord `BaseRecord`}
 * @typeParam TError - Custom error object that extends {@link https://refine.dev/docs/api-references/interfaceReferences#httperror `HttpError`}
 * @typeParam TVariables - Values for params. default `{}`
 *
 *
 */
export declare const useForm: <TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError, TVariables = {}>({ resource: resourceFromProps, action: actionFromProps, id: idFromProps, onMutationSuccess, onMutationError, redirect: redirectFromProps, successNotification, errorNotification, meta, metaData, mutationMode: mutationModeProp, liveMode, onLiveEvent, liveParams, undoableTimeout, dataProviderName, invalidates, queryOptions, createMutationOptions, updateMutationOptions, }?: UseFormProps<TData, TError, TVariables>) => UseFormReturnType<TData, TError, TVariables>;
export {};
//# sourceMappingURL=useForm.d.ts.map